{% from 'nav.html' import navBar %}

<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Carbon Data</title>
    <script type="text/javascript" src="{{ url_for('static', filename='util.js') }}"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../static/styles.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.2.1/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/date-fns/1.30.1/date_fns.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <div class="container">
        {{ navBar() }}
        
        <div class="chart-container">
            <canvas id="emission_rates"></canvas>
            <canvas id="emission_integral"></canvas>
        </div>
    </div>
</body>

<script type='text/javascript'>

    const metadata = {
        'emission_rates': {
            'ylabel': 'gCO2/s',
            'title': 'Instantaneous emission rates'
        },
        'emission_integral': {
            'ylabel': 'gCO2',
            'title': 'Emission integral over its duration'
        },
    }

    const d_events = {
        'input_transfer': {
            'interval_keys': ["input_transfer_start", "input_transfer_end"],
            'label': 'Input transfer',
        },
        'compute': {
            'interval_keys': ["compute_start", "compute_end"],
            'label': 'Compute',
        },
        'output_transfer': {
            'interval_keys': ["output_transfer_start", "output_transfer_end"],
            'label': 'Output transfer',
        },
    }

    const d_timing_labels = {
        "input_transfer_start": "Input transfer",
        // "input_transfer_start": "Start of input transfer",
        // "input_transfer_end": "End of input transfer",
        "compute_start": "Compute",
        // "compute_start": "Start of compute",
        // "compute_end": "End of compute",
        "output_transfer_start": "Output transfer",
        // "output_transfer_start": "Start of output transfer",
        // "output_transfer_end": "End of output transfer",
    }

    const colors = {
        "Azure:eastus": {
            "border": "rgb(220,20,60)",
            "background": "rgba(220,20,60,0.25)"
        },
        "Azure:westus": {
            "border": "rgb(0,191,255)",
            "background": "rgba(0,191,255,0.25)"
        }
    }


    const highlightComputeRegion = (ctx, lower, upper, df, color) => {
        if (df["Timestamp"][ctx.p0DataIndex] > lower && df["Timestamp"][ctx.p0DataIndex] < upper) {
            return color;
        }
        return "rgba(0, 0, 0, 0)";
    };

    const highlightTransferRegion = (ctx, inputLower, inputUpper, outputLower, outputUpper, df, color) => {
        if (df["Timestamp"][ctx.p0DataIndex] > inputLower && df["Timestamp"][ctx.p0DataIndex] < inputUpper || 
            df["Timestamp"][ctx.p0DataIndex] > outputLower && df["Timestamp"][ctx.p0DataIndex] < outputUpper) {
            return color;
        }
        return "rgba(0, 0, 0, 0)";
    }

    window.onload = function() {
        $.ajax({
            url: "/carbonDataFig",
            type: "get",
            success: function (data) {
                
                for (measurement in metadata) {
                    let datasets = [];

                    let options = {
                        title: {
                            display: true,
                            text: metadata[measurement]["title"]
                        },
                        legend: {
                            display: true,
                            position: "right"
                        },
                        scales: {
                            x: {
                                type: "time",
                                time: {
                                    unit: 'hour',
                                    stepSize: 2,
                                    displayFormats: {
                                        "hour": "MM-dd hh:mm aa"
                                    }
                                },
                                scaleLabel: {
                                    display: true,
                                    labelString: "Time"
                                },
                                ticks: {
                                    beginAtZero: true
                                }
                            },
                            y: {
                                scaleLabel: {
                                    display: true,
                                    labelString: metadata[measurement]["ylabel"]
                                }
                            }
                        },
                        plugins: {
                            annotation: {
                                annotations: []
                                
                            }
                        }
                    }


                    for (region in data[measurement]) {
                        const compute_df = data[measurement][region]["compute_df"];
                        const transfer_df = data[measurement][region]["transfer_df"];
                        const timings_df = data[measurement][region]["timings_df"]

                        for (key in Object.keys(compute_df["Timestamp"])) {
                            let date = new Date(compute_df["Timestamp"][key]);
                        }

                        const startCompute = timings_df["compute_start"]["Timestamp"];
                        const endCompute = timings_df["compute_end"]["Timestamp"];
                        const startInputTransfer = timings_df["input_transfer_start"]["Timestamp"];
                        const endInputTransfer = timings_df["input_transfer_end"]["Timestamp"];
                        const startOutputTransfer = timings_df["output_transfer_start"]["Timestamp"];
                        const endOutputTransfer = timings_df["output_transfer_end"]["Timestamp"];


                        let fillColor = colors[region]["background"]
                        datasets.push({
                            label: region + " - Compute",
                            data: Object.values(compute_df["Value"]),
                            pointRadius: 0,
                            fill: true,
                            stepped: true,
                            borderColor: colors[region]["border"],
                            segment: {
                                backgroundColor: ctx => highlightComputeRegion(ctx, startCompute, endCompute, compute_df, fillColor)
                            }
                        });

                        if (Object.keys(data[measurement][region]['transfer_df']['Timestamp']).length !== 0) {
                            datasets.push({
                                label: region + " - Transfer",
                                data: Object.values(transfer_df["Value"]),
                                pointRadius: 0,
                                fill: true,
                                stepped: true,
                                borderColor: colors[region]["border"],
                                borderDash: [5,2],
                                segment: {
                                    backgroundColor: ctx => {
                                        return highlightTransferRegion(ctx, startInputTransfer, endInputTransfer, startOutputTransfer, endOutputTransfer, compute_df, fillColor);
                                    }
                                }
                            });
                        }

                        let max_y_value = Math.max(Math.max(...Object.values(compute_df["Value"])), Math.max(...Object.values(transfer_df["Value"])));
                        let label;
                        let xValue = 0;
                        let yValue = 0;
                        let df;
                        let lowerTimestamp;
                        let upperTimestamp;

                        for (event in d_events) {
                            let xAdjust = 200;
                            label = d_timing_labels[d_events[event]["interval_keys"][0]]

                            if (event === "compute") {
                                df = compute_df;
                                lowerTimestamp = startCompute;
                                upperTimestamp = endCompute;
                            } else {
                                df = transfer_df;
                                if (event == "input_transfer") {
                                    lowerTimestamp = startInputTransfer;
                                    upperTimestamp = endInputTransfer;
                                    xAdjust = xAdjust * -1;
                                } else {
                                    lowerTimestamp = startOutputTransfer;
                                    upperTimestamp = endOutputTransfer;
                                }
                            }

                            if (Object.keys(df['Timestamp']).length === 0) {
                                continue;
                            }

                            let timestamps = Object.values(df["Timestamp"]);
                            let values = Object.values(df["Value"]);
                            for (let i = 0; i < timestamps.length; i++) {
                                if (timestamps[i] >= lowerTimestamp + ((upperTimestamp - lowerTimestamp) / 2)) {
                                    xValue = new Date(timestamps[i]);
                                    yValue = values[i] / 1.25;
                                    break;
                                }
                            }

                            options["plugins"]["annotation"]["annotations"].push({
                                type: 'label',
                                xValue: xValue,
                                yValue: yValue,
                                xAdjust: xAdjust,
                                yAdjust: -20,
                                backgroundColor: 'rgba(200,200,200,.5)',
                                content: label,
                                font: {
                                    size: 10
                                },
                                callout: {
                                    display: true,
                                    side: 10
                                }
                            });
                        }
                        
                    }

                    let timestampLabels = Object.values(data["emission_rates"]["Azure:eastus"]["compute_df"]["Timestamp"]);
                    let displayLabels = timestampLabels.map(timestamp => {
                        let date = new Date(timestamp);
                        let month = date.getUTCMonth() + 1;
                        let day = date.getUTCDate();
                        let year = date.getUTCFullYear();
                        let hour = date.getUTCHours();
                        let minutes = (date.getUTCMinutes() < 10 ? "0" : "") + date.getUTCMinutes();

                        let displayLabel = month + "/" + day + "/" + year + " " + hour + ":" + minutes;
                        return displayLabel;
                    })

                    const chart = new Chart(measurement, {
                        type: "line",
                        data: {
                            labels: timestampLabels,
                            datasets: datasets
                        },
                        options: options
                    });

                }
            }
        })
    }

</script>

</html>